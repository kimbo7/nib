# CrowdSec - Collaborative Threat Response

Behavioral detection engine with automated blocking and community-shared threat intelligence.

## Components

| Service | Image | Purpose |
|---------|-------|---------|
| nib-crowdsec | crowdsecurity/crowdsec:v1.6 | Security engine - parses logs, detects attacks |
| nib-bouncer-firewall | crowdsecurity/crowdsec-firewall-bouncer-iptables | Blocks banned IPs via iptables |

## How It Works

```
Suricata EVE logs → CrowdSec Engine → Decisions (ban/captcha) → Firewall Bouncer → iptables DROP
                                    ↕
                          CrowdSec Community API
                     (shared threat intelligence)
```

1. **Acquisition**: CrowdSec reads Suricata's EVE JSON logs in real-time
2. **Parsing**: Logs are parsed using the `crowdsecurity/suricata` collection
3. **Scenarios**: Attack patterns are matched (brute force, scans, exploits)
4. **Decisions**: Offending IPs are banned for a configurable duration
5. **Bouncing**: The firewall bouncer adds iptables rules to DROP traffic from banned IPs
6. **Sharing**: Attack data is shared with the CrowdSec community (opt-in), and you receive community blocklists in return

## Collections

Pre-installed collections:

| Collection | Purpose |
|------------|---------|
| `crowdsecurity/suricata` | Parse Suricata EVE alerts and detect attack patterns |
| `crowdsecurity/iptables` | Parse iptables logs for scan/brute force detection |
| `crowdsecurity/linux` | Parse syslog, auth.log for SSH brute force, etc. |

## Community Threat Intelligence

CrowdSec's community model works like a neighborhood watch:

- **Contribute**: Your detected attacks are shared anonymously
- **Receive**: You get a curated blocklist of IPs flagged by the community (~millions of nodes)
- **Opt-in**: Set `CROWDSEC_ENROLL_KEY` in `.env` to join (get key from [app.crowdsec.net](https://app.crowdsec.net))

## Configuration

### Enrollment (Optional)

Register at [app.crowdsec.net](https://app.crowdsec.net) to get an enrollment key. This enables:
- Community blocklist (pre-ban known bad IPs)
- Dashboard with attack statistics
- Alert notifications

```bash
# Set in .env
CROWDSEC_ENROLL_KEY=your-enrollment-key
```

### Ban Duration

Edit `config/profiles.yaml` to adjust ban durations:
- Default: 4 hours for generic attacks
- Suricata-triggered: 24 hours for IDS-detected attacks

### Bouncer

The firewall bouncer blocks at the iptables level with `DROP` action. Blocked packets are logged with prefix `NIB-BLOCKED:` for audit visibility.

## Bouncer Modes

NIB supports two bouncer modes, configured via `BOUNCER_MODE` in `.env`:

### Local Mode (default)

Blocks attackers on the NIB host using iptables. Best when NIB runs directly on the machine you want to protect (server, gateway).

```
BOUNCER_MODE=local
```

```
CrowdSec Engine → iptables bouncer → DROP on this host
```

### Sensor Mode (remote router/firewall)

No local bouncer. CrowdSec's LAPI is exposed on the network so external bouncers can pull decisions. Use this when NIB is a sensor and blocking should happen on a separate router or firewall.

```
BOUNCER_MODE=sensor
```

```
CrowdSec Engine (LAPI exposed on :8080)
    │
    ├──→ Router pulls decisions (native bouncer plugin)
    ├──→ scripts/router-sync.sh pushes decisions to router API
    └──→ CDN bouncer (Cloudflare, etc.)
```

### Securing Sensor Mode

Sensor mode exposes the CrowdSec LAPI on the network. **Do not expose LAPI to the public internet.**

Choose a security posture:

#### Best: Reverse proxy with mTLS

Put LAPI behind nginx/Caddy with mutual TLS. Both NIB and the bouncer present client certificates. This is the strongest option for untrusted networks.

```bash
# Keep LAPI bound to localhost
CROWDSEC_API_BIND=127.0.0.1

# nginx forwards to localhost:8080, requires client cert
# See: https://docs.crowdsec.net/docs/local_api/tls_auth/
```

#### Good: Dedicated management network + firewall allowlist

Bind to a management VLAN/interface, firewall to known bouncer IPs, use long random API keys, change the default port.

```bash
# Bind to management interface IP
CROWDSEC_API_BIND=10.0.99.10
# Non-default port
CROWDSEC_API_PORT=9443

# Firewall: only allow router bouncer IP
sudo iptables -A INPUT -p tcp --dport 9443 -s 10.0.99.1 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 9443 -j DROP
```

#### Minimum: Allowlist + API key + non-default port

```bash
CROWDSEC_API_BIND=192.168.1.10
CROWDSEC_API_PORT=9443

sudo iptables -A INPUT -p tcp --dport 9443 -s 192.168.1.1 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 9443 -j DROP
```

**In all cases:**
- Use **unique bouncer API keys per device** — don't share keys across routers (`make add-router-bouncer` for each)
- CrowdSec LAPI authenticates bouncers via API key (long random token, generated by `cscli bouncers add`)
- Run **`make audit`** to verify exposure
- See [CrowdSec TLS documentation](https://docs.crowdsec.net/docs/local_api/tls_auth/) for full mTLS setup

### Setting Up Sensor Mode

1. Set `BOUNCER_MODE=sensor` in `.env`
2. Install: `make install-crowdsec`
3. Generate a bouncer key: `make add-router-bouncer`
4. Choose your blocking method:

#### Option A: Native Router Plugin (pfSense / OPNsense) — Recommended

Both pfSense and OPNsense have native CrowdSec packages that handle everything automatically (firewall rules, alias management, decision polling). **Use this option if your router supports it** — no need for the sync script.

**pfSense:**
1. Install the `crowdsec` package from System > Package Manager
2. Configure under Services > CrowdSec:
   - LAPI URL: `http://<nib-host>:8080`
   - Bouncer API Key: (from `make add-router-bouncer`)
3. The plugin creates a pf alias and firewall rule automatically — no manual firewall setup needed

**OPNsense:**
1. Install `os-crowdsec` from System > Firmware > Plugins
2. Configure under Services > CrowdSec > Settings:
   - LAPI URL: `http://<nib-host>:8080`
   - Bouncer API Key: (from `make add-router-bouncer`)
3. Enable the firewall bouncer under CrowdSec > Bouncers
4. The plugin manages the firewall alias and rules automatically

**Verify** the plugin is connected:
```bash
# On the NIB host — the router bouncer should appear as "validated"
make bouncer-status
```

#### Option B: Router Sync Script

For routers without native CrowdSec plugins. The sync script polls LAPI and pushes decisions to the router's REST API.

```bash
# Configure in .env
ROUTER_TYPE=mikrotik       # mikrotik, opnsense, pfsense, openwrt, generic
ROUTER_URL=https://192.168.1.1
ROUTER_USER=admin
ROUTER_PASS=your-password
ROUTER_LIST_NAME=nib-blocklist
CROWDSEC_LAPI_KEY=<key from make add-router-bouncer>

# One-shot sync
make router-sync

# Continuous daemon (polls every 60s)
make router-sync-daemon
```

**Supported routers:**

| Router | Type | Auth Model | How It Blocks | Failure Mode |
|--------|------|------------|---------------|--------------|
| MikroTik (RouterOS 7+) | `mikrotik` | HTTP basic auth | Address list via REST API | Fails open |
| OpenWrt | `openwrt` | HTTP session auth (luci-rpc) | ipset/nftables set | Fails open |
| pfSense (no plugin) | `pfsense` | HTTP basic auth | pf alias via [fauxapi](https://github.com/ndejong/pfsense_fauxapi) | Fails open |
| OPNsense (no plugin) | `opnsense` | HTTP basic auth | Firewall alias via API | Fails open |
| Any REST API | `generic` | HTTP basic auth | POSTs JSON to your endpoint | Depends on endpoint |

> **Fails open** means if the sync script loses connection to LAPI, no new blocks are applied — but existing blocks on the router remain until they expire.
>
> **pfSense / OPNsense users**: Prefer Option A (native plugin) above. Only use the sync script if you cannot install the plugin.

**MikroTik setup (RouterOS 7.1+):**

The sync script pushes banned IPs to a MikroTik address list via the REST API. The address list alone does nothing — you must also create firewall rules that reference it.

1. **Enable the REST API** (disabled by default):
   ```
   /ip/service/set www-ssl disabled=no
   ```
   The REST API runs on the `www-ssl` (port 443) or `www` (port 80) service — it is part of the web interface, not the legacy `api` service. Confirm it's running:
   ```
   /ip/service/print where name=www-ssl
   ```

2. **Create a dedicated API user** (least privilege):
   ```
   /user/group/add name=nib-sync policy=read,write,api
   /user/add name=nib-sync group=nib-sync password=your-strong-password
   ```
   Use this user for `ROUTER_USER` / `ROUTER_PASS` instead of `admin`.

3. **Create firewall rules** that drop traffic from the address list. Place them near the top of your filter rules (before any accept rules):
   ```
   /ip/firewall/filter/add chain=input src-address-list=nib-blocklist action=drop comment="NIB CrowdSec" place-before=0
   /ip/firewall/filter/add chain=forward src-address-list=nib-blocklist action=drop comment="NIB CrowdSec" place-before=0
   ```
   Without these rules, IPs are added to the list but no traffic is actually blocked.

4. **Configure `.env`** and start syncing:
   ```bash
   ROUTER_TYPE=mikrotik
   ROUTER_URL=https://192.168.1.1
   ROUTER_USER=nib-sync
   ROUTER_PASS=your-strong-password
   ROUTER_LIST_NAME=nib-blocklist
   ROUTER_VERIFY_SSL=false          # set true if using a valid cert
   ```

5. **Verify** it works:
   ```bash
   # Run a one-shot sync
   make router-sync

   # Check address list on MikroTik
   /ip/firewall/address-list/print where list=nib-blocklist

   # Start continuous sync
   make router-sync-daemon
   ```

**OpenWrt setup:**

The sync script authenticates via LuCI RPC and executes ipset/nftables commands on the router. You must create the set and firewall rule first.

1. **Install required packages**:
   ```
   opkg update
   opkg install luci-mod-rpc luci-lib-json
   /etc/init.d/uhttpd restart
   ```

2. **Create a persistent nftables set**. Add to `/etc/nftables.d/nib-blocklist.nft` (or `/etc/firewall.nib` and include it):
   ```
   set nib-blocklist {
       type ipv4_addr
       flags timeout
   }
   ```
   Then load it:
   ```
   nft add set inet fw4 nib-blocklist '{ type ipv4_addr; flags timeout; }'
   ```

3. **Add firewall rules** to drop traffic from the set:
   ```
   nft add rule inet fw4 input ip saddr @nib-blocklist drop
   nft add rule inet fw4 forward ip saddr @nib-blocklist drop
   ```
   To persist across reboots, add these to `/etc/nftables.d/nib-blocklist.nft` as well.

4. **Configure `.env`**:
   ```bash
   ROUTER_TYPE=openwrt
   ROUTER_URL=https://192.168.1.1
   ROUTER_USER=root
   ROUTER_PASS=your-password
   ROUTER_LIST_NAME=nib-blocklist
   ```

5. **Verify**:
   ```bash
   make router-sync
   # On the router:
   nft list set inet fw4 nib-blocklist
   ```

**pfSense setup (without native plugin):**

If you cannot install the native CrowdSec plugin (Option A), the sync script uses [fauxapi](https://github.com/ndejong/pfsense_fauxapi) to manage firewall aliases via REST.

1. **Install fauxapi** on pfSense:
   ```
   pkg install pfSense-pkg-faux-api
   ```
   If the package is unavailable for your pfSense version, use Option A (native plugin) or the `generic` router type with a custom endpoint instead.

2. **Create a firewall alias** in Firewall > Aliases:
   - Name: `nib_blocklist` (underscores, not hyphens — pfSense alias names don't allow hyphens)
   - Type: Host(s)
   - Leave entries empty — the sync script populates it

3. **Create firewall rules** in Firewall > Rules > WAN (and LAN if needed):
   - Action: Block
   - Source: Single host or alias → `nib_blocklist`
   - Destination: Any
   - Description: `NIB CrowdSec`

4. **Create a fauxapi key** under System > Faux API > Credentials. Note the API key and secret.

5. **Configure `.env`**:
   ```bash
   ROUTER_TYPE=pfsense
   ROUTER_URL=https://192.168.1.1
   ROUTER_USER=PFFA-fauxapi-key
   ROUTER_PASS=fauxapi-secret
   ROUTER_LIST_NAME=nib_blocklist
   ```

**OPNsense setup (without native plugin):**

If you cannot install the native CrowdSec plugin (Option A), the sync script manages firewall aliases via the OPNsense API.

1. **Create a firewall alias** in Firewall > Aliases:
   - Name: `nib-blocklist`
   - Type: Host(s)
   - Leave entries empty — the sync script populates it

2. **Create firewall rules** in Firewall > Rules > WAN:
   - Action: Block
   - Source: `nib-blocklist` (alias)
   - Destination: Any
   - Description: `NIB CrowdSec`

3. **Create an API key** under System > Access > Users. Select your user, create an API key (downloads a `key`/`secret` pair).

4. **Configure `.env`**:
   ```bash
   ROUTER_TYPE=opnsense
   ROUTER_URL=https://192.168.1.1
   ROUTER_USER=api-key
   ROUTER_PASS=api-secret
   ROUTER_LIST_NAME=nib-blocklist
   ```

5. **Verify**:
   ```bash
   make router-sync
   # Check in OPNsense GUI: Firewall > Diagnostics > Aliases → nib-blocklist should show IPs
   ```

**Generic REST API setup:**

For custom firewalls or middleware. The sync script sends JSON requests to your endpoint:

```
# Block request (POST):
{"action": "block", "ip": "1.2.3.4", "list": "nib-blocklist", "source": "nib-crowdsec"}

# Unblock request (DELETE):
{"action": "unblock", "ip": "1.2.3.4", "list": "nib-blocklist", "source": "nib-crowdsec"}
```

Authentication uses HTTP basic auth (`ROUTER_USER` / `ROUTER_PASS`). Your endpoint should return HTTP 2xx on success.

```bash
ROUTER_TYPE=generic
ROUTER_URL=https://firewall.internal/api/blocklist
ROUTER_USER=nib
ROUTER_PASS=your-api-secret
```

**Router sync troubleshooting:**

```bash
# Check if LAPI is reachable and has decisions
curl -s -H "X-Api-Key: YOUR_BOUNCER_KEY" http://127.0.0.1:8080/v1/decisions | python3 -m json.tool

# Test router API connectivity (MikroTik example)
curl -sk -u nib-sync:password https://192.168.1.1/rest/ip/firewall/address-list?list=nib-blocklist

# Run sync with debug output — the script prints each IP it adds/removes
make router-sync

# Check state file (tracks what was last synced)
cat /tmp/nib-router-sync-last.json
```

Common issues:
- **IPs synced but traffic not blocked**: Missing firewall rules on the router. The address list alone does nothing.
- **Authentication failures**: Check `ROUTER_USER` / `ROUTER_PASS`. MikroTik REST API requires the `api` policy on the user group.
- **SSL errors**: Set `ROUTER_VERIFY_SSL=false` for self-signed router certs.
- **Empty sync**: No active CrowdSec decisions yet. Trigger a test with `make test-alert`, wait 30s, then retry.

#### Option C: Cloudflare / CDN Bouncer

CrowdSec provides official bouncers for edge services:

- **Cloudflare**: [crowdsec-cloudflare-bouncer](https://github.com/crowdsecurity/cs-cloudflare-bouncer) — blocks at the CDN edge
- **AWS WAF**: [crowdsec-aws-waf-bouncer](https://github.com/crowdsecurity/cs-aws-waf-bouncer)

Point them at your NIB host's LAPI (`http://<nib-host>:8080`) with the bouncer key from `make add-router-bouncer`.

## Management Commands

```bash
# View active decisions (bans)
make decisions

# View CrowdSec alerts
make alerts

# Manually ban an IP
make ban IP=1.2.3.4

# Manually unban an IP
make unban IP=1.2.3.4

# List installed collections
make collections

# Check bouncer status
make bouncer-status

# View CrowdSec metrics
make metrics
```

## Adding Log Sources

Edit `config/acquis.yaml` to add more log sources:

```yaml
# Example: also monitor auth.log
- filenames:
    - /var/log/auth.log
  labels:
    type: syslog
```

## Troubleshooting

```bash
# Check CrowdSec engine status
make logs-crowdsec

# Verify Suricata log parsing
docker exec nib-crowdsec cscli metrics

# Test a scenario manually
docker exec nib-crowdsec cscli alerts list

# Check bouncer connection
docker exec nib-crowdsec cscli bouncers list

# Inspect iptables rules
sudo iptables -L crowdsec-blacklists -n
```
